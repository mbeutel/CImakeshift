# Azure Pipelines job template for CMake builds
# Version 0.2.0
# Author: Moritz Beutel
#
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# Supported compiler versions:
#
# Windows:
#   MSVC: 19_0, 19_1, 19_2
#   Clang: 9
#   NVCC: 10_1, 10_2
#
# Linux:
#   GCC: 5, 6, 7, 8, 9
#   Clang: 4, 5, 6, 7, 8, 9
#   NVCC: 10_1, 10_2
#
# MacOS:
#   GCC: 5, 6, 7, 8, 9
#   AppleClang: 8_1, 9, 9_1, 10, 10_0_1, 11


parameters:

  # Cache the directory '$(Build.BinariesDirectory)/dependencies'
  cache: True
  tag: ''

  # Vcpkg repository
  vcpkgRepo: 'https://github.com/microsoft/vcpkg.git'
  vcpkgRef: ''

  # Repository with additional port and triplet overlays
  vcpkgOverlayRepo: ''
  vcpkgOverlayRef: ''

  # Platform options
  os: ''
  platforms: []

  # C++ options
  cxxCompiler: ''
  cxxCompilerVersions: []

  # CUDA options
  cudaCompiler: ''
  cudaCompilerVersion: ''
  cudaPackages: [] # cf. https://docs.nvidia.com/cuda/cuda-installation-guide-microsoft-windows/index.html#install-cuda-software for Windows, https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64/ for Linux

  # Vcpkg options
  vcpkgTriplet: '<platform>-<os>'
  vcpkgArgs: ''
  vcpkgPackages: []

  # Build options
  cmakeListsTxtPath: '$(Build.SourcesDirectory)/CMakeLists.txt'
  cmakeBuildConfigurations: [Debug, RelWithDebInfo]
  cmakeGenerator: 'Ninja'
  cmakeConfigArgs: ''
  cmakeBuildArgs: ''
  cmakeTestArgs: ''

  targets: []
#    target.tag: ''                   # overrides parameters.tag
#    target.os: ''                    # overrides parameters.os
#    target.platforms: []             # overrides parameters.platforms
#    target.cxxCompiler               # overrides parameters.cxxCompiler
#    target.cxxCompilerVersions       # overrides parameters.cxxCompilerVersions
#    target.cudaCompiler              # overrides parameters.cudaCompiler
#    target.cudaCompilerVersion       # overrides parameters.cudaCompilerVersion
#    target.cmakeBuildConfigurations  # overrides parameters.cmakeBuildConfigurations
#    target.vcpkgTriplet              # overrides parameters.vcpkgTriplet
#    target.vcpkgArgs                 # overrides parameters.vcpkgArgs; can refer to parameters.vcpkgArgs as '<vcpkgArgs>'
#    target.vcpkgPackages             # overrides parameters.vcpkgPackages; can refer to parameters.vcpkgPackages as '<vcpkgPackages>'
#    target.cudaPackages              # overrides parameters.cudaPackages; can refer to parameters.cudaPackages as '<cudaPackages>'
#    target.cmakeGenerator            # overrides parameters.cmakeGenerator
#    target.cmakeConfigArgs           # overrides parameters.cmakeConfigArgs; can refer to parameters.cmakeConfigArgs as '<cmakeConfigArgs>'
#    target.cmakeBuildArgs            # appends to parameters.cmakeBuildArgs
#    target.cmakeTestArgs             # appends to parameters.cmakeTestArgs

jobs:
- ${{ each target in parameters.targets }}:
  - ${{ each platform in coalesce(target.platforms, parameters.platforms) }}:
    - ${{ each cxxCompilerVersion in coalesce(target.cxxCompilerVersions, parameters.cxxCompilerVersions) }}:
      - job: '${{ coalesce(target.os, parameters.os) }}_${{ coalesce(target.cxxCompiler, parameters.cxxCompiler) }}${{ cxxCompilerVersion }}_${{ coalesce(target.cudaCompiler, parameters.cudaCompiler) }}${{ coalesce(target.cudaCompilerVersion, parameters.cudaCompilerVersion) }}_${{ coalesce(target.tag, parameters.tag) }}_${{ platform }}'
        pool:
          name: Azure Pipelines
          ${{ if and(eq(coalesce(target.os, parameters.os), 'Windows'), or(and(eq(coalesce(target.cxxCompiler, parameters.cxxCompiler), 'Clang'), le(9, cxxCompilerVersion)), and(eq(coalesce(target.cxxCompiler, parameters.cxxCompiler), 'MSVC'), eq(cxxCompilerVersion, '19_2')))) }}:
            vmImage: 'windows-2019'
          ${{ if and(eq(coalesce(target.os, parameters.os), 'Windows'), eq(cxxCompilerVersion, '19_1')) }}:
            vmImage: 'vs2017-win2016'
          ${{ if and(eq(coalesce(target.os, parameters.os), 'Windows'), eq(cxxCompilerVersion, '19_0')) }}:
            vmImage: 'vs2015-win2012r2'
          ${{ if eq(coalesce(target.os, parameters.os), 'Linux') }}:
            vmImage: 'ubuntu-18.04'
          ${{ if and(eq(coalesce(target.os, parameters.os), 'MacOS'), or(eq(coalesce(target.cxxCompiler, parameters.cxxCompiler), 'GCC'), and(ne(cxxCompilerVersion, '9'), ne(cxxCompilerVersion, '8_1')))) }}:
            vmImage: 'macOS-10.14'
          ${{ if and(eq(coalesce(target.os, parameters.os), 'MacOS'), eq(coalesce(target.cxxCompiler, parameters.cxxCompiler), 'AppleClang'), or(eq(cxxCompilerVersion, '9'), eq(cxxCompilerVersion, '8_1'))) }}:
            vmImage: 'macOS-10.13'

        steps:
        - pwsh: |
            $revision='1' # Update this when making incompatible changes to the build pipeline definition.
            if ($IsWindows) { $tripletOS = "windows" }
            elseif ($IsLinux) { $tripletOS = "linux" }
            elseif ($IsMacOS) { $tripletOS = "osx" }
            $vcpkgTriplet = "${{ coalesce(target.vcpkgTriplet, parameters.vcpkgTriplet) }}" -replace "<os>","$tripletOS" -replace "<platform>","${{ platform }}"
            $parametersCudaPackagesRaw = "${{ join(' ', coalesce(parameters.cudaPackages)) }}"
            $cudaPackagesRaw = ("${{ join(' ', coalesce(target.cudaPackages, parameters.cudaPackages)) }}" -replace "<cudaPackages>",$parametersCudaPackagesRaw -replace '\s+',' ').Trim() + ' '
            if ($IsWindows) {
                if ("${{ coalesce(target.cxxCompiler, parameters.cxxCompiler) }}" -eq "Clang") {
                    #$vsPath = &"${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"  -latest -prerelease -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath
                    #$clangClPath = Join-Path $vsPath 'VC\Tools\Llvm\bin\clang-cl.exe'
                    $clangClPath = "${env:ProgramFiles}\LLVM\bin\clang-cl.exe"
                    $clangClCompatPath = $clangClPath -replace '\\','/'
                    $cmakeCompilerFlag = "-DCMAKE_C_COMPILER=`"$clangClCompatPath`" -DCMAKE_CXX_COMPILER=`"$clangClCompatPath`""
                    if ("${{ platform }}" -eq "x86") {
                        # Workaround for https://gitlab.kitware.com/cmake/cmake/issues/16259
                        echo "##vso[task.setvariable variable=CFLAGS]-m32"
                        echo "##vso[task.setvariable variable=CXXFLAGS]-m32"
                    }
                }
                if("${{ coalesce(target.cudaCompiler, parameters.cudaCompiler) }}") {
                    $cudaVersion = "${{ coalesce(target.cudaCompilerVersion, parameters.cudaCompilerVersion) }}" -replace "_","."
                    $cmakeCudaCompilerFlag = "-DCMAKE_CUDA_COMPILER=`"$env:SystemDrive/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v$cudaVersion/bin/nvcc.exe`""
                    $cudaPackages = "nvcc $cudaPackagesRaw" -replace '\s+',' ' -replace ' ',"_$cudaVersion "
                }
            }
            elseif ($IsLinux) {
                New-Item -Type Directory -Force $HOME/bin
                echo "##vso[task.setvariable variable=PATH]$HOME/bin:${env:PATH}"
                if ("${{ coalesce(target.cxxCompiler, parameters.cxxCompiler) }}" -eq "GCC") {
                    echo "##vso[task.setvariable variable=CC]gcc-${{ cxxCompilerVersion }}"
                    echo "##vso[task.setvariable variable=CXX]g++-${{ cxxCompilerVersion }}"
                }
                elseif ("${{ coalesce(target.cxxCompiler, parameters.cxxCompiler) }}" -eq "Clang") {
                    if (${{ cxxCompilerVersion }} -lt 7) {
                        $versionSuffix = ".0"
                    }
                    echo "##vso[task.setvariable variable=CC]clang-${{ cxxCompilerVersion }}$versionSuffix"
                    echo "##vso[task.setvariable variable=CXX]clang++-${{ cxxCompilerVersion }}$versionSuffix"
                }
                if("${{ coalesce(target.cudaCompiler, parameters.cudaCompiler) }}") {
                    $cudaVersion = "${{ coalesce(target.cudaCompilerVersion, parameters.cudaCompilerVersion) }}" -replace "_","."
                    $cmakeCudaCompilerFlag="-DCMAKE_CUDA_COMPILER=`"/usr/local/cuda-$cudaVersion/bin/nvcc`""
                    $cudaVersion_Dash = $cudaVersion -replace '\.','-'
                    $cudaPackages = "cuda-core cuda-cudart-dev $cudaPackagesRaw" -replace '\s+',' ' -replace ' ',"-$cudaVersion_Dash "
                }
            }
            elseif ($IsMacOS) {
                if ("${{ coalesce(target.cxxCompiler, parameters.cxxCompiler) }}" -eq "GCC") {
                    echo "##vso[task.setvariable variable=CXXFLAGS_OLD]$CXXFLAGS"
                    echo "##vso[task.setvariable variable=CXXFLAGS]$CXXFLAGS -fvisibility=hidden -fvisibility-inlines-hidden"
                    echo "##vso[task.setvariable variable=CC]gcc-${{ cxxCompilerVersion }}"
                    echo "##vso[task.setvariable variable=CXX]g++-${{ cxxCompilerVersion }}"
                }
            }
            $vcpkgArgs = "${{ coalesce(target.vcpkgArgs, parameters.vcpkgArgs) }}" -replace "<vcpkgArgs>","${{ parameters.vcpkgArgs }}"
            $vcpkgPackages = "${{ join(' ', coalesce(target.vcpkgPackages, parameters.vcpkgPackages)) }}" -replace "<vcpkgPackages>","${{ join(' ', parameters.vcpkgPackages) }}"
            $buildCacheKey = @(
                "revision-$revision",
                "${{ coalesce(target.cxxCompiler, parameters.cxxCompiler) }}${{ cxxCompilerVersion }}",
                "${{ coalesce(target.cudaCompiler, parameters.cudaCompiler) }}${{ coalesce(target.cudaCompilerVersion, parameters.cudaCompilerVersion) }}",
                $vcpkgTriplet,
                "${{ parameters.vcpkgRepo }}${{ parameters.vcpkgRef }}",
                "${{ parameters.vcpkgOverlayRepo }}${{ parameters.vcpkgOverlayRef }}",
                $vcpkgArgs,
                $vcpkgPackages,
                $cudaPackages,
                "${{ coalesce(target.tag, parameters.tag) }}"
            ) -join ' '
            $cmakeConfigArgs = "${{ join(' ', coalesce(target.cmakeConfigArgs, parameters.cmakeConfigArgs)) }}" -replace "<cmakeConfigArgs>","${{ join(' ', parameters.cmakeConfigArgs) }}"
            $cmakeBuildArgs = "${{ join(' ', coalesce(target.cmakeBuildArgs, parameters.cmakeBuildArgs)) }}" -replace "<cmakeBuildArgs>","${{ join(' ', parameters.cmakeBuildArgs) }}"
            $cmakeTestArgs = "${{ join(' ', coalesce(target.cmakeTestArgs, parameters.cmakeTestArgs)) }}" -replace "<cmakeTestArgs>","${{ join(' ', parameters.cmakeTestArgs) }}"
            echo "##vso[task.setvariable variable=buildCacheKey]$buildCacheKey"
            #echo "##vso[task.setvariable variable=Path]$(Build.BinariesDirectory)/dependencies/cmake/bin;${env:Path}"
            echo "##vso[task.setvariable variable=VCPKG_ROOT]$(Build.BinariesDirectory)/dependencies/vcpkg"
            echo "##vso[task.setvariable variable=VCPKG_TRIPLET]$vcpkgTriplet"
            echo "##vso[task.setvariable variable=vcpkgArgs]$vcpkgArgs"
            echo "##vso[task.setvariable variable=vcpkgPackages]$vcpkgPackages"
            echo "##vso[task.setvariable variable=cudaPackages]$cudaPackages"
            echo "##vso[task.setvariable variable=cmakeConfigArgs]$cmakeCompilerFlag $cmakeCudaCompilerFlag $cmakeConfigArgs"
            echo "##vso[task.setvariable variable=cmakeBuildArgs]$cmakeBuildArgs"
            echo "##vso[task.setvariable variable=cmakeTestArgs]$cmakeTestArgs"
          displayName: Set environment variables

        - task: CacheBeta@1
          displayName: Cache dependencies
          inputs:
            key: '"$(buildCacheKey)"'
            path: '$(Build.BinariesDirectory)/dependencies'
            cacheHitVar: 'dependencyCacheHit'
            condition: and(parameters.cache, ne('${{ parameters.vcpkgRef }}', ''))

        - pwsh: |
            if ($IsWindows) {
                if ("${{ coalesce(target.cxxCompiler, parameters.cxxCompiler) }}" -eq "Clang") {
                    $clangVersion = "${{ cxxCompilerVersion }}.0.0"
                    Invoke-WebRequest http://releases.llvm.org/$clangVersion/LLVM-${clangVersion}-win64.exe -OutFile "$HOME/LLVM-installer.exe"
                    Start-Process -Wait "$HOME/LLVM-installer.exe" /S
                }
                if ("${{ coalesce(target.cudaCompiler, parameters.cudaCompiler) }}") {
                    $cudaVersion = "${{ coalesce(target.cudaCompilerVersion, parameters.cudaCompilerVersion) }}" -replace "_","."
                    $cudaVersion_URL = @{
                        '10.1' = 'http://developer.download.nvidia.com/compute/cuda/10.1/Prod/network_installers/cuda_10.1.105_win10_network.exe'
                        '10.2' = 'http://developer.download.nvidia.com/compute/cuda/10.2/Prod/network_installers/cuda_10.2.89_win10_network.exe'
                    }
                    Invoke-WebRequest $cudaVersion_URL[$cudaVersion] -OutFile "$HOME/cuda_installer_network.exe"
                    Start-Process -Wait "$HOME/cuda_installer_network.exe" -s $env:cudaPackages
                }
            }
            elseif ($IsLinux) {
                $packages = @('cmake')
                & wget -O "$HOME/kitware-archive-latest.asc" https://apt.kitware.com/keys/kitware-archive-latest.asc
                & sudo apt-key add "$HOME/kitware-archive-latest.asc"
                & sudo apt-add-repository "deb https://apt.kitware.com/ubuntu/ bionic main"
                if ("${{ coalesce(target.cxxCompiler, parameters.cxxCompiler) }}" -eq "GCC") {
                    & sudo apt-add-repository ppa:ubuntu-toolchain-r/test
                    $packages += ('gcc-${{ cxxCompilerVersion }}', 'g++-${{ cxxCompilerVersion }}')
                }
                elseif ("${{ coalesce(target.cxxCompiler, parameters.cxxCompiler) }}" -eq "Clang") {
                    if (${{ cxxCompilerVersion }} -lt 7) {
                        $versionSuffix = ".0"
                    }
                    & sudo apt-add-repository "deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-${{ cxxCompilerVersion }} main"
                    $packages += "clang-${{ cxxCompilerVersion }}$versionSuffix"
                }
                if ("${{ coalesce(target.cudaCompiler, parameters.cudaCompiler) }}") {
                    $cudaVersion = "${{ coalesce(target.cudaCompilerVersion, parameters.cudaCompilerVersion) }}" -replace "_","."
                    $ubuntuVersion = "ubuntu1804"
                    $cudaVersion_installer = @{
                        '10.1' = "cuda-repo-${ubuntuVersion}_10.1.105-1_amd64.deb"
                        '10.2' = "cuda-repo-${ubuntuVersion}_10.2.89-1_amd64.deb"
                    }
                    $installer = $cudaVersion_installer[$cudaVersion]
                    & wget http://developer.download.nvidia.com/compute/cuda/repos/$ubuntuVersion/x86_64/$installer
                    & sudo dpkg -i $installer
                    & wget https://developer.download.nvidia.com/compute/cuda/repos/$ubuntuVersion/x86_64/7fa2af80.pub
                    & sudo apt-key add 7fa2af80.pub
                    $packages += $env:cudaPackages -split ' '
                }
                & sudo apt-get update
                & sudo apt-get install $packages
                & ln -s /usr/bin/cmake $HOME/bin/cmake
                & ln -s /usr/bin/ctest $HOME/bin/ctest
            }
            elseif ($IsMacOS) {
                & sudo xcode-select -s /Applications/Xcode_10.1.app/Contents/Developer
                if ("${{ coalesce(target.cxxCompiler, parameters.cxxCompiler) }}" -eq "GCC") {
                    & brew install gcc@${{ cxxCompilerVersion }}
                }
                if ("${{ parameters.vcpkgRef }}") {
                    & brew install gcc@9
                }
            }
          displayName: Install tools

        - pwsh: |
            if ("${{ parameters.vcpkgOverlayRepo }}" -and "${{ parameters.vcpkgOverlayRef }}") {
                & git clone ${{ parameters.vcpkgOverlayRepo }} "$(Build.BinariesDirectory)/dependencies/overlay-repo"
                cd "$(Build.BinariesDirectory)/dependencies/overlay-repo"
                & git checkout --quiet --force ${{ parameters.vcpkgOverlayRef }}
                New-Item -Type Directory -Force "$(Build.BinariesDirectory)/dependencies/overlay-repo/vcpkg/ports"
                New-Item -Type Directory -Force "$(Build.BinariesDirectory)/dependencies/overlay-repo/vcpkg/triplets"
                echo "##vso[task.setvariable variable=vcpkgOverlayArgs]--overlay-ports=`"$(Build.BinariesDirectory)/dependencies/overlay-repo/vcpkg/ports`" --overlay-triplets=`"$(Build.BinariesDirectory)/dependencies/overlay-repo/vcpkg/triplets`"
            }
            else {
                echo "##vso[task.setvariable variable=vcpkgOverlayArgs]"
            }
          displayName: Clone Vcpkg overlay repository
          condition: and(ne(variables.dependencyCacheHit, 'true'), ne('${{ parameters.vcpkgRef }}', ''))
        
        - task: run-vcpkg@0
          displayName: Run Vcpkg to install dependencies
          inputs:
            vcpkgDirectory: '$(Build.BinariesDirectory)/dependencies/vcpkg'
            vcpkgGitURL: '${{ parameters.vcpkgRepo }}'
            vcpkgGitCommitId: '${{ parameters.vcpkgRef }}'
            vcpkgTriplet: '$(VCPKG_TRIPLET)'
            vcpkgArguments: '$(vcpkgOverlayArgs) $(vcpkgArgs) $(vcpkgPackages)'
          condition: and(ne(variables.dependencyCacheHit, 'true'), ne('${{ parameters.vcpkgRef }}', ''))

        - pwsh: |
            Remove-Item -Recurse -Force "$(Build.BinariesDirectory)/dependencies/vcpkg/buildtrees"
            Remove-Item -Recurse -Force "$(Build.BinariesDirectory)/dependencies/vcpkg/downloads"
            Remove-Item -Recurse -Force "$(Build.BinariesDirectory)/dependencies/vcpkg/packages"
          displayName: Delete temporary files
          condition: and(ne(variables.dependencyCacheHit, 'true'), ne('${{ parameters.vcpkgRef }}', ''))

        - pwsh: |
            if ("${{ coalesce(target.cxxCompiler, parameters.cxxCompiler) }}" -eq "GCC") {
                echo "##vso[task.setvariable variable=CXXFLAGS]$CXXFLAGS_OLD"
                echo "##vso[task.setvariable variable=CC]gcc"
                echo "##vso[task.setvariable variable=CXX]g++"
            }
            elseif ("${{ coalesce(target.cxxCompiler, parameters.cxxCompiler) }}" -eq "AppleClang") {
                $appleClangVersion_xcodeVersion = @{
                    '8_1'    = '8.3.3'
                    '9'      = '9.2'   # also 9.1, 9.0.1, 9.0
                    '9_1'    = '9.4.1'
                    '10'     = '10.1'  # also 10
                    '10_0_1' = '10.3'  # also 10.2, 10.2.1
                    '11'     = '11.3'  # also 11.1, 11.2, 11.2.1
                }
                $xcodeVersion = $appleClangVersion_xcodeVersion["${{ cxxCompilerVersion }}"]
                & sudo xcode-select -s /Applications/Xcode_$xcodeVersion.app/Contents/Developer
                echo "##vso[task.setvariable variable=CC]clang"
                echo "##vso[task.setvariable variable=CXX]clang++"
            }
          displayName: Set environment variables
          condition: eq(variables['Agent.OS'], 'Darwin')

        - ${{ each config in coalesce(target.cmakeBuildConfigurations, parameters.cmakeBuildConfigurations) }}:
          - task: run-cmake@0
            displayName: 'Build ${{ config }}'
            inputs:
              cmakeListsOrSettingsJson: 'CMakeListsTxtAdvanced'
              cmakeListsTxtPath: '${{ parameters.cmakeListsTxtPath }}'
              useVcpkgToolchainFile: true
              buildDirectory: '$(Build.BinariesDirectory)/build/${{ config }}'
              cmakeAppendedArgs: '-G "${{ coalesce(target.cmakeGenerator, parameters.cmakeGenerator) }}" $(cmakeConfigArgs) -DCMAKE_BUILD_TYPE=${{ config }}'
              buildWithCMakeArgs: '--parallel --verbose --config ${{ config }} $(cmakeBuildArgs)'

          - pwsh: |
              & ctest -V -T Test $env:cmakeTestArgs
            displayName: 'Run tests for ${{ config }}'
            workingDirectory: '$(Build.BinariesDirectory)/build/${{ config }}'

        - task: PublishTestResults@2
          displayName: Publish test results
          inputs:
            testResultsFormat: 'cTest'
            testResultsFiles: '$(Build.BinariesDirectory)/build/*/Testing/*/Test.xml'
            testRunTitle: '$(Agent.JobName)'
